"use strict";(self.webpackChunkwiki_blog=self.webpackChunkwiki_blog||[]).push([[450],{6029:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"isNaN-vs-Number.isNaN","metadata":{"permalink":"/isNaN-vs-Number.isNaN","editUrl":"https://github.com/streltsov/blog/blog/2022-03-10-isNaN-vs-Number-isNaN.md","source":"@site/blog/2022-03-10-isNaN-vs-Number-isNaN.md","title":"The difference between isNaN and Number.isNaN","description":"How to check for NaN value and what is the difference between isNaN and Number.isNaN","date":"2022-03-10T00:00:00.000Z","formattedDate":"March 10, 2022","tags":[{"label":"JavaScript","permalink":"/tags/java-script"},{"label":"wtfjs","permalink":"/tags/wtfjs"}],"readingTime":3.16,"truncated":false,"authors":[]},"content":"JavaScript method **Number.isNaN** and its evil twin brother global function\\n**isNaN** may confuse you and make you think if they has the same name \u2013 then\\nthey behave the same way.\\n\\nBut they do not.\\n\\nIn this article I\'ll try to explain in detail the difference between the twins\\nand how to reliably check for `NaN` value.\\n\\nBut first, let\'s recall what the hell `NaN` value is.\\n\\n## NaN\\n\\n**NaN** \u2014 is a two-faced value, which stands for *Not-a-Number*, but\\nparadoxically has a type of `number`.\\n\\nYou can get a `NaN` if you try to do some crazy operation like multiplying\\ninfinity by zero:\\n\\n```js\\nInfinity * 0 // -> NaN\\n```\\nand other useless operatons:\\n\\n```js\\n0 / 0                 // -> NaN\\n0 * Infinity          // -> NaN\\n\\"JavaScript\\" - 777    // -> NaN\\nundefined + undefined // -> NaN\\n```\\n\\nBut also you can get a `NaN` in some practical case, for example when parsing a\\nstring with `parseInt`:\\n\\n```js\\nparseInt(\\"string\\"); // -> NaN\\n```\\n\\nHere, we would like to know if the operation failed or not. How do we do that?\\nWell, if it\'s failed then the result should be `NaN`, so we check for `NaN`\\n\\n```js\\nconst maybeNaN = parseInt(\\"some string\\");\\n\\nif (maybeNaN == NaN) {\\n  // Code if parsing failed\\n} else {\\n  // Code if parsing succeeded\\n}\\n```\\nBut, thats not gonna work as comparison `maybeNaN == NaN` always will be false\\nbecause in JavaScript nothing is equal to `NaN`, even `NaN` itself.\\n\\nSo, how do we check for `NaN`? Let\'s try this global function `isNaN`.\\n\\n## Global Function isNaN\\n\\nConsidering the function\'s name we can assume that the function checks for\\n`NaN` value. So, if we pass the `NaN` value it will return true and if it\'s\\nsomething else we will get `false`. Let\'s check it out if it\'s true:\\n\\n```js\\nisNaN(NaN);          // -> true\\n```\\n\\nWorks like a charm with `NaN`! Let\'s try different values:\\n\\n```js\\nisNaN(42); // -> false\\nisNaN(0);  // -> false\\n```\\n\\nSeems to be working too!\\n\\nBut all JS quirks begins when we pass to the function some value with type\\nother than `number`. Let\'s see:\\n\\n```js\\nisNaN(undefined);    // -> true\\nisNaN(\\"JavaScript\\"); // -> true\\nisNaN({a: 1});       // -> true\\nisNaN([]);           // -> true\\n```\\n\\nSo, what the heck is going on here?\\n\\nAccording to [specification](https://tc39.es/ecma262/#sec-isnan-number) the\\nfirst thing that function `isNaN` does, is implicitly converts passed argument\\nto type `number`. And only after converting checks if it is a `NaN`\\n\\nYou can see it if you\'ll pass to `isNaN` a value with type `symbol` or\\n`bigint`. JavaScript wont be able to convert these types to `number`:\\n\\n![TypeError \u043f\u0440\u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0435 \u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u044e isNaN \u0442\u0438\u043f\u043e\u0432 symbol \u0438 bigint](/img/isNaN-vs-Number-isNaN/type-error.jpg)\\n\\nTo sum up, if you want to check for `NaN` value with `isNaN` function, you\\nshould feed it only with values of type `number`. Or you can use a much more\\nreliable method `Number.isNaN`.\\n\\n## Number.isNaN method\\n\\nNumber.isNaN works as you would expect it to work. It returns `true` only in\\none particular case when you provide it with `NaN` value as argument and\\n`false` in all other cases:\\n\\n```js\\nNumber.isNaN(NaN);          // -> true\\n\\nNumber.isNaN(42);           // -> false\\nNumber.isNaN(BigInt(42));   // -> false\\nNumber.isNaN(\\"JavaScript\\"); // -> false\\nNumber.isNaN([1, 2, 3]);    // -> false\\nNumber.isNaN(undefined);    // -> false\\nNumber.isNaN(null);         // -> false\\nNumber.isNaN(Symbol());     // -> false\\n```\\n\\nUnder the hood **Number.isNaN** checks if provided argument is of type\\n`number`. If it\'s not a `number` \u2013 it will return `false`. If it is \u2013 it will\\ncheck this value for `NaN` and accordingly return `true` or `false`\\n\\n## Test yourself\\n\\n```js\\nisNaN(\\"string\\") // -> ?\\nisNaN(42) // -> ?\\nisNaN(NaN) // -> ?\\n\\nNumber.isNaN(\\"string\\") // -> ?\\nNumber.isNaN(42) // -> ?\\nNumber.isNaN(NaN) // -> ?\\n```\\n\\n<details>\\n  <summary>Answer</summary>\\n`true`\\n`false`\\n`true`\\n`false`\\n`false`\\n`true`\\n\\n</details>"}]}')}}]);